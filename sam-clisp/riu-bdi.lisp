#|RIU - BDIThis file contains the necessary functions to handle the BDI model of ALESIt is represented in a list with 3 elements:1) Beliefs: tje set of memories that Ales has retrieved2) Desires: the desires of Ales (for now they are either to be happy or to be sad)3) Intentions: here we will store the intentionality status of Ales as a number between 0 and 1 (this differs from the BDI model 			   where Intentions means "committed plans")			   |#(defvar *riu-GOALS* nil);; Goals contains the lists of entities and expressions that advance the goal and the ones that hamper the goal(setf *riu-GOALS*	'((happy 		(happy fun play cute rich)		(sad dead bored work force rusty awkward crashed angry))	  (sad 		(sad dead bored work force rusty awkward crashed angry)		(happy fun play cute rich))	))(defun init-ALES-BDI ()	(init-BDI "Ales" () (list 'happy) 0.75);;	(init-BDI "Ales" () (list 'sad) ()))(defun init-BDI (id beliefs desires intentions)	(list id beliefs desires intentions))(defun get-beliefs (bdi)	(second bdi))(defun add-belief (bdi belief)	(setf (second bdi) (cons belief (second bdi))))(defun get-desires (bdi)	(third bdi))(defun get-intentions (bdi)	(fourth bdi))(defun print-BDI (bdi)	(format t "BDI for ~S~%" (first bdi))	(format t "beliefs:~% ~S~%" (get-beliefs bdi))	(format t "desires:~% ~S~%" (get-desires bdi))	(format t "intentions:~% ~S~%" (get-intentions bdi)))(defun assess-goals (bdi expressions)	(let ((score 0))		(dolist (goal (get-desires bdi))			(setf score (+ score (assess-goal goal expressions)))		)		score	))(defun assess-goal (goal expressions)	(let ((score 0)		  (good (second (assoc goal *riu-GOALS*)))		  (bad (third (assoc goal *riu-GOALS*))))		(dolist (element expressions)			(if (listp element)				(setf score (+ score (assess-goal goal element)))				(setf score (+ score								(cond									((member element good) 1)									((member element bad) -1)									(t 0)								))				)			)		)		score	))(defun undesired-effects (bdi expressions)	(let ((res nil))		(dolist (goal (get-desires bdi))			(setf res (append res (undesired-effects-goal goal (assoc ':expressions expressions))))		)		(remove-duplicates res)	))(defun undesired-effects-goal (goal expressions)	(let ((res nil)		  (good (second (assoc goal *riu-GOALS*)))		  (bad (third (assoc goal *riu-GOALS*))))		(dolist (element expressions)			(if (listp element)				(when (undesired-effects-goal goal element) 					(setf res (append res (list element)))				)				(setf res (append res								(cond									((member element bad) (list element))									(t ())								))				)			)		)		res	))(defun predict-outcome-of-action (action block bdi)	(let ((additional-entities (fourth action))		  (additional-expressions (fifth action)))		(when (member 'prediction *riu-debug*)			(format t "predict-outcome-of-action ~a~%" (first action))			(format t "additional entities for story: ~s~%" additional-entities)			(format t "additional expressions for story: ~s~%" additional-expressions))				(let ((analogies				(sort					(mapcar #'(lambda (memory) 								(let ((analogy-results 										(analogy block (third action) memory 												:additional-entities-story additional-entities 												:additional-expressions-story additional-expressions)))									(when (member 'prediction *riu-debug*) (format t "predict-outcome-of-action analogy result ~a~%" analogy-results))													(append analogy-results (list memory))								)							)							(get-beliefs bdi))					#'(lambda (m1 m2) (> (first m1) (first m2)))				)))			(if analogies				(let* ((selected-analogy (first analogies))					   (selected-memory (third selected-analogy))					   (phase2 (rest (assoc 'phase2 (rest (assoc :structure (rest selected-memory))))))					   (mapped-phase2 phase2))					(when (member 'prediction *riu-debug*) (format t "predict-outcome-of-action selected memory ~a~%" (first selected-memory)))					(when (member 'prediction *riu-debug*) (format t "predict-outcome-of-action phase2 ~a~%" phase2))					(dolist (mapping (second selected-analogy))						(setf mapped-phase2 (replace-recursive-nondestructive (first mapping) (second mapping) mapped-phase2))					)					(when (member 'prediction *riu-debug*) (format t "predict-outcome-of-action mapped phase2 ~a~%" mapped-phase2))					(list (first selected-analogy) mapped-phase2)				)				()			)		)				));; This function returns the probability of Ales retrieving a memory according to its intentionality state:;; If the memory-clause contains a specific probability, that one is used. Otherwise, the BDI model is used to obtain a probability(defun probability-of-memory (bdi memory-clause)	(if (= 3 (length memory-clause))		(third memory-clause)		(+ 0.2 (* 0.8 (fourth bdi)))	))(defun probability-of-rejecting-unwanted-actions (bdi)	(* 0.5 (fourth bdi)))(defun probability-of-rejecting-unwanted-actions-after-selected (bdi)	(fourth bdi))(defun probability-of-executing-wanted-actions (bdi)	(fourth bdi))(defun probability-of-adding-expression-to-action (bdi)	(fourth bdi))(defun evaluate-probability (p)	(< (/ (random 10000) 10000.0) p))